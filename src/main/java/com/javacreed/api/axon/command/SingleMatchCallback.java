package com.javacreed.api.axon.command;

import java.util.ArrayList;
import java.util.List;
import java.util.Objects;
import java.util.function.Consumer;

/**
 * A builder class that allows the creation and setup of a single consumer callback in a fluent manner. This builder
 * allows the association of events (or any other object) with {@link Consumer}. For every event send to the constructed
 * callback, only one consumer is invoked if one if found (otherwise none). In the event of two or more consumers are
 * found, only the closest consumer to the event being processed is invoked. This builder allows the caller to take
 * specific actions based on the events generated by the command. Say that a warning needs to be displayed if a
 * rejection event is published by the command. Following is a possible setup
 *
 * <pre>
 * Callback callback = SingleMatchCallback.builder()
 *                                        .whenThen(RejectedEvent.class, e -> { <em>Show warning</em> })
 *                                        .whenThen(AcceptedEvent.class, e -> { <em>Act on accepted event</em> })
 *                                        .orElse(e -> { <em>A catch all option</em> });
 * </pre>
 *
 * @author Albert Attard
 */
public class SingleMatchCallback {

  private static class Pair<T> {

    private final Class<T> type;
    private final Consumer<T> consumer;

    private Pair(final Class<T> type, final Consumer<T> consumer) throws NullPointerException {
      this.type = Objects.requireNonNull(type);
      this.consumer = Objects.requireNonNull(consumer);
    }

    public void accept(final Object event) {
      @SuppressWarnings("unchecked")
      final T t = (T) event;
      consumer.accept(t);
    }

    public boolean isAssignableFrom(final Class<?> type) {
      return this.type.isAssignableFrom(type);
    }

    public boolean isAssignableFrom(final SingleMatchCallback.Pair<?> other) {
      return this.type.isAssignableFrom(other.type);
    }
  }

  public static SingleMatchCallback builder() {
    return new SingleMatchCallback();
  }

  private final List<SingleMatchCallback.Pair<?>> consumers = new ArrayList<>();

  private SingleMatchCallback() {}

  private Callback build() {
    /* Return the noop callback if no consumers are specified */
    if (this.consumers.isEmpty()) {
      return NoopCallback.instance();
    }

    final List<SingleMatchCallback.Pair<?>> consumers = new ArrayList<>(this.consumers);

    return new Callback() {
      @Override
      public void apply(final Object event) {
        final Class<?> eventType = event.getClass();
        SingleMatchCallback.Pair<?> bestMatch = null;
        for (final SingleMatchCallback.Pair<?> pair : consumers) {
          if (pair.isAssignableFrom(eventType)
              && (bestMatch == null || bestMatch.isAssignableFrom(pair))) {
            bestMatch = pair;
          }
        }

        if (bestMatch != null) {
          bestMatch.accept(event);
        }
      }
    };
  }

  public Callback end() {
    return build();
  }

  public Callback orElse(final Consumer<Object> consumer) throws NullPointerException {
    return whenThen(Object.class, consumer).build();
  }

  public <T> SingleMatchCallback whenThen(final Class<T> type, final Consumer<T> consumer)
      throws NullPointerException {
    consumers.add(new SingleMatchCallback.Pair<>(type, consumer));
    return this;
  }
}