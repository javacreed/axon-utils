package com.javacreed.api.axon.command;

import java.util.concurrent.CompletableFuture;
import java.util.concurrent.TimeUnit;

import org.axonframework.commandhandling.CommandBus;
import org.axonframework.commandhandling.CommandCallback;
import org.axonframework.commandhandling.CommandExecutionException;
import org.axonframework.commandhandling.CommandMessage;
import org.axonframework.commandhandling.gateway.CommandGateway;
import org.axonframework.messaging.Message;
import org.axonframework.messaging.MetaData;

/**
 * The command service is a simple wrapper on the {@link CommandGateway} which provides the caller the facility to
 * listen to the events generated by the command. The called can stop listening to these events by using the returned
 * {@link IgnoreHandle} instance. Note that the command is not effected by ignoring of the events.
 * <p/>
 * In order not to mix between the {@link CommandGateway} methods and the new methods that provide a listener hook, the
 * new methods are prefixed with <code>xxxAndListen()</code> such as {@link #sendAndListen(Object, Callback)}.
 *
 * @author Albert Attard
 * @see IgnoreHandle
 * @see CommandGateway
 */
public interface CommandService {

  /**
   * Sends the given <code>command</code>, and have the result of the command's execution reported to the given
   * <code>callback</code>.
   * <p/>
   * The given <code>command</code> is wrapped as the payload of the {@link CommandMessage} that is eventually posted on
   * the {@link CommandBus}, unless the given <code>command</code> already implements {@link Message}. In that case, a
   * {@link CommandMessage} is constructed from that message's payload and {@link MetaData}.
   *
   * @param command
   *          The command to dispatch (which cannot be <code>null</code>)
   * @param callback
   *          The callback to notify when the command has been processed (which cannot be <code>null</code>)
   * @param <C>
   *          The type of command
   * @param <R>
   *          The type of result expected from command execution
   * @throws NullPointerException
   *           if the given <code>command</code> or <code>callback</code> are <code>null</code>
   */
  <C, R> void send(C command, CommandCallback<? super C, R> callback);

  /**
   * Sends the given <code>command</code> and returns immediately, without waiting for the command to execute. The
   * caller will therefore not receive any feedback on the command's execution.
   * <p/>
   * The given <code>command</code> is wrapped as the payload of the {@link CommandMessage} that is eventually posted on
   * the {@link CommandBus}, unless given <code>command</code> already implements {@link Message}. In that case, a
   * {@link CommandMessage} is constructed from that message's payload and {@link MetaData}.
   *
   * @param command
   *          The command to dispatch (which cannot be <code>null</code>)
   * @param <T>
   *          The type of command
   * @param <R>
   *          The type of result expected from command execution
   * @return a {@link CompletableFuture} which is resolved when the command is executed
   * @throws NullPointerException
   *           if the given <code>command</code> is <code>null</code>
   */
  <T, R> CompletableFuture<R> send(T command) throws NullPointerException;

  /**
   * Sends the given <code>command</code>, and have the result of the command's execution reported to the given
   * <code>callback</code>.
   * <p/>
   * The given <code>command</code> is wrapped as the payload of the {@link CommandMessage} that is eventually posted on
   * the {@link CommandBus}, unless the given Command already implements {@link Message}. In that case, a
   * {@link CommandMessage} is constructed from that message's payload and {@link MetaData}.
   * </p>
   * The command and generated events are linked through metadata. The command handler needs to pass the metadata to the
   * events as otherwise these will not be properly linked
   *
   * @param command
   *          The command to dispatch (which cannot be <code>null</code>)
   * @param callback
   *          The callback to notify with all events generated by the given <code>command</code> (which cannot be
   *          <code>null</code>)
   * @param <T>
   *          The type of command
   * @return A handle through which the caller can ignore any further events (without effecting the command execution)
   * @throws NullPointerException
   *           if the given <code>command</code> or <code>callback</code> are <code>null</code>
   * @throws FailedToGenerateUniqueActionReferenceException
   *           if it fails to create a unique reference
   */
  <T> IgnoreHandle sendAndListen(T command, Callback callback)
      throws NullPointerException, FailedToGenerateUniqueActionReferenceException;

  /**
   * Sends the given <code>command</code> and wait for it to execute. The result of the execution is returned when
   * available. This method will block indefinitely, until a result is available, or until the thread is interrupted.
   * When the thread is interrupted, this method returns <code>null</code>. If command execution resulted in an
   * exception, it is wrapped in a {@link CommandExecutionException}.
   * <p/>
   * The given <code>command</code> is wrapped as the payload of the {@link CommandMessage} that is eventually posted on
   * the {@link CommandBus}, unless the given <code>command</code> already implements {@link Message}. In that case, a
   * {@link CommandMessage} is constructed from that message's payload and {@link MetaData}.
   * <p/>
   * Note that the interrupted flag is set back on the thread if it has been interrupted while waiting.
   *
   * @param command
   *          The command to dispatch (which cannot be <code>null</code>)
   * @param <C>
   *          The type of command
   * @param <R>
   *          The type of result expected from command execution
   * @return the result of command execution, or {@code null} if the thread was interrupted while waiting for the
   *         command to execute
   * @throws NullPointerException
   *           if the given <code>command</code> is <code>null</code>
   * @throws CommandExecutionException
   *           when an exception occurred while processing the command
   */
  <C, R> R sendAndWait(C command) throws NullPointerException, CommandExecutionException;

  /**
   * Sends the given <code>command</code> and wait for it to execute. The result of the execution is returned when
   * available. This method will block until a result is available, or the given <code>timeout</code> was reached, or
   * until the thread is interrupted. When the timeout is reached or the thread is interrupted, this method returns
   * <code>null</code>. If command execution resulted in an exception, it is wrapped in a
   * {@link CommandExecutionException}.
   * <p/>
   * The given <code>command</code> is wrapped as the payload of the {@link CommandMessage} that is eventually posted on
   * the {@link CommandBus}, unless Command already implements {@link Message}. In that case, a {@link CommandMessage}
   * is constructed from that message's payload and {@link MetaData}.
   * <p/>
   * Note that the interrupted flag is set back on the thread if it has been interrupted while waiting.
   *
   * @param command
   *          The command to dispatch
   * @param timeout
   *          The amount of time the thread is allows to wait for the result
   * @param unit
   *          The unit in which {@code timeout} is expressed
   * @param <C>
   *          The type of command
   * @param <R>
   *          The type of result expected from command execution
   * @return the result of command execution, or <code>null</code. if the thread was interrupted while waiting for
   *         the command to execute
   *
   * &#64;throws NullPointerException
   *           if the given <code>command</code> or <code>unit</code> are <code>null</code>
   * @throws CommandExecutionException
   *           when an exception occurred while processing the command
   */
  <C, R> R sendAndWait(C command, long timeout, TimeUnit unit) throws NullPointerException, CommandExecutionException;

}
